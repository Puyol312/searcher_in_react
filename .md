# Ciclos de vida en React

Los componentes de clase tienen métodos especiales que React llama automáticamente en distintos momentos del ciclo de vida del componente. Existen 3 grandes etapas en un componente de React.

## Montaje (Mount) 

El componente aparece por primera vez en pantalla.

Orden:
1. constructor
2. render
3. componentDidMount

Acá se hacen llamadas a APIs, timeouts, intervalos, suscripciones, etc.

## Actualización (Update)
Ocurre cuando:

- cambian las props
- cambia el state
- se fuerza un re-render

Orden:

1. render
2. componentDidUpdate

Acá se reacciona a cambios en props o state.

## Desmontaje (Unmount)

El componente se elimina del DOM.

Solo se llama:

1. componentWillUnmount

Acá se limpian intervalos, listeners, etc.

## Posible situacion problema.

```jsx
//... componente que extiende a React.Component
pullData() {
  console.log("Se activo pullData");
  setTimeout(() => {
    this.setState({
      data: "nueva Data"
    });
  });
}
render(){
  console.log("Se activo render");
  this.pullData();
  return <div>{this.state.data}</div>
}
```
Esto genera un problema grave, se ejecuta el metodo render se entra a pullData y se vuelve a ingresar a render pero no porque finalizo la llamada a pullData sino porque pullData altero el state por lo tanto react nota un cambio en el state entonces vuelve a ejecutar render.

```node
-----------       -----------
|  render | ----->| pullData|
-----------       -----------
    ^                  |
    |                  |
    --------------------
```

- Se ejecuta render().
- render() llama a pullData().
- pullData() ejecuta this.setState(...).
- React detecta un cambio en el estado.
- React vuelve a ejecutar render().
- Y como render() vuelve a llamar pullData(), otra vez se ejecuta setState.

**Regla de oro:** nunca llamar a setState dentro de render() directa o indirectamente.
(render debe ser puro, sin efectos secundarios).